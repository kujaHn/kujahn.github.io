---
title: "스트림 : 기본 개념"
excerpt: "컬렉션을 대체할 스트림의 등장."
categories:
    - JAVA8
tags:
    - Stream
last_modified_at: 2021-05-16
---

# 스트림
* 거의 모든 애플리케이션에서는 컬렉션을 만들고 처리한다. 하지만 이를 처리하는데에는 조금 아쉬운 부분들이 많다.
* 이들을 조금 더 쉽고 편하게 처리하기 위해서 **스트림이 등장했다.**

## 스트림의 장점

### 1. 선언형 코드로 컬렉션 데이터를 처리가능.
* 루프와 조건문을 이용해 키가 180이 넘고, 체육 성적이 90점이 넘는 남학생들을 성적순으로 나열한 이름 리스트를 만들어 보자.
  ```java
  void 반복문(){
      List<Student> result = new ArrayList<>();
      for(Student student : students){
          if(student.getGender().equals(Gender.Male)) {
              if(student.getHeight() >= 180){
                    if(student.getPsxGrade >= 90) result.add(student);
              } 
          } 
      }
      // 성적 순 나열 후 이름 매핑
      for(Student student : result){
          위상정렬...
      }
  }
  ```
  * 완전히 코드를 구현하지 않았지만, 어쨋든 매우 복잡해지는 것을 알 수 있다. 이 코드들의 아쉬운점들은 다음과 같다.
  1. 루프, 조건문 등 제어 블록들을 만들때마다 코드가 복잡해지고 가독성이 떨어진다.
  2. 복잡한 데이터 파이프라인을 가지는 로직을 짤때 실수할 가능성이 높아진다.
    
* 스트림을 통해서는 이를 정말 쉽게 해결이 가능하다.
  ```java
  List<Student> result = new ArrayList<>();
  result.stream()
      .filter(s -> s.getGender.equals(Gender.Male) 
                   && s.getHeight() >= 180 
                   && s.getPsxGrade >= 90)
      .sorted(comparing(Student::getPsxGrade))
      .map(Student::getName)
      .collect(toList());
  ```
    * 근 몇십줄에 달하는 코드를 **선언형 코드**로 획기적으로 줄일 수 있다.
      (더해서 `동작 파라미터화` 활용하면 금상첨화.)
    * 이처럼 **루프, 조건문 등 제어 블록을 동작을 구현하지 않아도 바로 지정이 가능**해진다.
    * 또한  `선언형 코드` 덕분에 복잡한 데이터 파이프라인을 단순한 빌더 형식으로 만들 수 있다.
        * 또 이 덕분에 `지연성`과 `쇼트서킷`과 같은 최적화를 얻을 수 있다.
  
### 2. 내부반복
* 외부반복을 지원하는 컬렉션(Iterator)과 달리, **스트림은 `내부 반복`을 지원**한다.
* 멀티스레드 코드를 구현하지 않아도 데이터를 병렬로 처리할 수 있다.
* 기존 멀티스레드 코드를 구현하려면, `synchronized`를 사용하고 `thread`에서 설정을 하는 등 복잡한 절차가 필요하다.
  (성능 저하는 덤)
* 스트림에서는 **`stream()`을 `parallelStream()`으로 바꿔**주기만 하면 멀티스레드에 대한 스트레스를 해소 할 수 있다.
* 데이터 처리 과정을 병렬화하면 스레드와 락을 걱정할 필요가 없다.

***

## 스트림 시작하기.
* 스트림이란 `데이터 처리 연산`을 지원하도록 `소스`에서 추출된 `연속된 요소`.

### 데이터 처리 연산
* 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 DB와 비슷한 연산을 함.
    * 예시 : `filter`, `map`, `reduce`, `find`, `match`, `sort`
    
### 소스
* 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
* 정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
* 즉, 리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.

### 연속된 요소
* 스트림은 컬렉션과 같이 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
* **컬렉션**은 시간, 공간의 복잡성과 관련된 **요소 저장 및 접근 연산**이 주를 이룸
* **스트림**은 `filter`, `sorted`, `map` 처럼 **표현 계산식**이 주를 이룸.
  * 결론적으로 컬렉션은 데이터 위주이고, 스트림은 계산 위주이다.
    
### 정리
```java
void selectLowCaloricDishesV3() {
    List<String> dishesName = menu.stream()             // 데이터 소스로부터 스트림 얻기
            .filter(d -> d.getCalories() <400)          // 파이프라인 연산 시작
            .sorted(comparing(Dish::getCalories))       // 칼로리를 기준으로 정렬
            .map(Dish::getName)                         // 이름 매핑
            .limit(3)                                   // 3개까지 스트림의 크기 축소
            .collect(Collectors.toList());              // 스트림을 리스트로 변환
}
```

## 컬렉션 vs 스트림

### 1. 데이터 계산
* **데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이.**
    #### 컬렉션 : 현재 자료구조가 포함하는 모든 값을 메모리에 저장
    * 컬렉션의 **모든 요소는 컬렉션에 추가하기 전에 계산**되어야 한다.
    #### 스트림 : 이론적으로는 요청할 때만 요소를 계산
    * 사용자가 요청하는 값만 스트림에서 추출. (어떻게 보면 컬렉션의 지연로딩 버전)

### 2. 탐색
* **컬렉션과 스트림 모두 딱 한 번만 탐색이 가능**하다.
    * 탐색된 스트림의 요소는 소비되어 없어지기 때문에 다시 탐색하려면 새로운 스트림을 생성해야 한다.
        * 그렇기 때문에 **초기 데이터는 컬렉션 처럼 반복 가능한 데이터 소스여야 한다.** (변화되서는 안됨.)

### 3. 데이터 반복 처리 방법
* 컬렉션 인터페이스를 사용하려면 **사용자가 직접 요소를 반복해야 함. 이것을 외부 반복이라 함.** (ex: for-each 등등)
* 스트림 라이브러리는 **내부 반복을 사용**한다. 이점은 다음과 같다.
    * 작업을 투명하게 병렬로 처리하거나, 더 최적화된 다양한 순서로 처리할 수 있다.
    * 외부반복도 가능하나 스스로 관리 해야 함. (`synchronized`를 통해서..)

***

## 스트림 연산
* 스트림의 `파이프라이닝`의 특성덕분에 지연로딩이 가능하다 했다.
    * 중간 연산 : 연결할 수 있는 스트림
    * 최종 연산 : 스트림을 닫는 연산
* `filter`m `sotred` 같은 중간 연산은 다른 스트림을 반환.
* 스트림의 특징은 **아무 연산도 수행하지 않고, 중간 연산들을 합친 다음 최종 연산으로 한번에 처리**한다.
    ```java
    void lazyLoadingTest() {
        List<String> highCaloricMenu = menu.stream()
                .filter(dish -> {
                    System.out.println("filtering : " + dish.getName());
                    return dish.getCalories() > 300;
                })
                .map(dish -> {
                    System.out.println("mapping : " + dish.getName());
                    return dish.getName();
                })
                .limit(3)
                .collect(toList());
        System.out.println(highCaloricMenu);
    }
    ```
    * 결과
    ```
    filtering : pork
    mapping : pork
    filtering : beef
    mapping : beef
    filtering : chicken
    mapping : chicken
    [pork, beef, chicken]
    ```
    * 이 결과를 통해, 중간연산들을 한번에 처리 한 후 리스트로 변환하는 것을 알 수 있다.

## 요약
* 스트림의 장점
    * 선언형 코드
        * 기존의 조건식, 반복문 블록들을 선언형 코드로 정리가 된다.
        * 선언형 코드 덕분에 파이프라이닝을 더욱 간단하게 할 수 있다. (깔끔해지는 것은 덤.)
    * 내부 반복
        * 최적화하는데 적절하다.
        * `parallelStream()`을 사용하면 `synchronized`나 스레드 락으로부터 자유로워진다.
* 스트림 연산
    * 스트림은 중간연산과 최종연산으로 이루어져 있다.
        * **중간 연산 : 다른 스트림을 반환**
        * **최종 연산 : 스트림이 아닌 결과를 반환 ex: collect(toList())**
        * 중간연산으로는 어떤 결과도 생성 할 수 없다.
  
### 참고 자료
* 모던 자바 인 액션
* JAVA Reference
---
title: "람다식 활용1 : 실행 어라운드 패턴"
excerpt: "실행 어라운드 패턴을 예로들어 람다를 이해하자"
categories:
  - JAVA8
tags:
  - Lambda
last_modified_at: 2021-05-15
---

# 람다 활용 1편
* 람다와 동작 파라미터화로 유연하고 간결한 코드를 구현하는데 도움을 주는 실용적인 예시를 살펴보자.

## 목차
* [실행 어라운드 패턴](#실행-어라운드-패턴)
* [기본형 특화](#기본형-특화)

***

## 실행 어라운드 패턴
* 기본적으로 자원처리에 사용되는 실행 어라운드 패턴(순환패턴)은 자원을 열고 -> 처리하고 -> 닫는 순서로 이루어진다.
* 이렇게 **처리 과정이 열고 닫는 순서 사이에 있는 패턴을 `실행 어라운드 패턴`이라고 한다.**

  ### 1st. 동작 파라미터화
  * 원래라면 매번 다른 요청마다 **매번 열고 닫는 과정을 반복해서 코드를 짜야 한다.**
    
      <img src="/image/JAVA8/ch3/ch3_3.png" alt="실행 어라운드 패턴의 전략화.png" class="align-center">
    * **이 패턴을 동작 파라미터화를 한다면, 무의미한 반복 없이 클라이언트의 요청에 따라 넘겨주는 파라미터만 바꾸면 된다.**
    ```java
    // try-with-resources 구문
    private String oldProcessFile() throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
            return br.readLine();
        }
    }
    ```
  ### 2nd. 함수형 인터페이스 생성
  * `@FunctionalInterface`를 통해 함수형 인터페이스를 명시해놓자.
    ```java
    @FunctionalInterface
    private interface BufferedReaderProcessor {
        String process(BufferedReader br) throws IOException;
    }
    ```
  ### 3nd. 동작 실행
  * `BufferedReaderProcessor`에 전략 패턴(A, B, C, D, ... 처리코드)에 따라 `processFile` 메소드의 동작 실행  
    ```java
    private string processFile(BufferedReaderProcessor p) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
            return p.process(br);
        }
    }
    ```
  ### 4nd. 익명 메소드
  * 동작 실행 메소드
    ```java
    private string processFile(BufferedReaderProcessor p) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
            return p.process(br);
        }
    }
    ```
  * 한 행을 처리하는 전략 패턴 익명 메소드화
      <img src="/image/JAVA8/ch3/ch3_4.png" alt="실행 어라운드 패턴의 전략화.png" class="align-center">
    
  ### 5nd. 람다로 변환
  * 이제 원하는 전략 패턴을 람다로 변환하자.
    ```java
    // 한 행을 처리하는 코드
    String oneLine = processFile((BufferedReader br) -> br.readLine());
    ```
    ```java
    // 두 행을 처리하는 코드
    String oneLine = processFile((BufferedReader br) -> br.readLine() + br.readLine());
    ```

## 기본형 특화
* 자바 타입은 **기본형**(Primitive : `boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double`)과 **참조형**(Reference : Primitive 제외 전부)이 있다.
* **제네릭 함수형 인터페이스 (`Predicate<T>`, `Consumer<T>`, `Function<T>`)의 제네릭 파라미터는 참조형만 가능**하다.
    * 이를 해결하기 위해서 **기본형을 참조형으로 변환하는 기능을 제공하는데 이를 `박싱`이라 한다.**
    * 박싱에 대한 내용은 <a href = "https://kujahn.github.io/java/%EB%B0%95%EC%8B%B1-%EC%96%B8%EB%B0%95%EC%8B%B1/" >여기</a>를 참고하자
    * **참조형을 기본형으로 변환하는 반대 동작을 `언박싱` 이라고 한다.**
    * **보통 명시적으로 쓰지 않아도 변환이 되는데 이를 `오토 박싱`이라 한다.** (메모리 비용이 크다.)
<br></br>
* 기본형 특화는 오토박싱을 피하기 위해 설계된 것으로 대부분의 **함수형 인터페이스명 앞에 타입을 써놓으면 된다.**
    * `Predicate<T>` -> `IntPredicate<T>`, `LongPredicate<T>`, `DoublePredicate<T>` (**T -> boolean**)
    * `Consumer<T>` -> `IntConsumer<T>`, `LongConsumer<T>`, `DoubleConsumer<T>` (**T-> void**)
    * 등등....


## 람다의 주의사항

### 예외를 던지는 함수형 인터페이스
* **함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않음.**
* 그러므로 예외를 던지는 람다 표현식을 만들려면... (`ExceptionLambda.java`)
    * **확인된 예외를 선언하는 함수형 인터페이스를 직접 정의**
    * 람다를 **try/catch 블록**으로 감싸야함.

## 요약
* 실행 어라운드 패턴을 예를들어 전략 패턴을 간소화한 람다를 활용하면 추상화와 캡슐화에 유리하다.
<br></br>
* **참조 타입을 기본으로 갖는 `제네릭 함수형 인터페이스`를 사용 중 기본형으로 변환할 경우 기본형 특화 인터페이스를 사용하자.**
    * **`오토 박싱` 기능으로 인해 명시적으로 참조형에서 기본형으로 변경하지 않아도 되지만 메모리 비용이 크다.**
  
### 참고 자료
* 모던 자바 인 액션
* JAVA Reference

---
title: "스트림 활용 : 스트림 필터링, 슬라이싱"
excerpt: "`filtering`, `takeWhile`, `dropWhile`, `limit`, `skip` 같은 스트림 필터링 및 슬라이싱 기능을 배워보자."
categories:
  - JAVA8
tags:
  - Stream
last_modified_at: 2021-05-16
---

# 필터링

## filter() : boolean 타입 기준 필터링
* `filter()`는 `boolean` 타입을 인수로 받는다. 그에 대표적인 것이 바로 `Precidate<T>`이다.
* 결과가 True가 되는 모든 요소를 포함하는 스트림을 반환한다. (중간 연산)
  ```java
  result.stream()
        .filter(Student s -> s.getGender().equals(Gender.Male))
  -> 성별이 남자인 모든 학생들을 가지는 스트림을 반환
  ```

## distinct() : 고유 요소 필터링
* 스트림의 요소 중 **중복되는 것들을 제거**하고 싶은경우 사용하는 메소드.
* **고유 요소로 이루어진 스트림을 반환** (이 고유요소는 객체의 스트림에서 만든 `hashCode`, `equals` 로 결정됨.)
  ```java
  List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4)
  number.stream()
        .filter(i i-> i % 2 == 0)   -> 짝수 필터링(2, 2, 4)
        .distinct()                 -> hashCode와 equals를 사용해 중복 제거(2, 4)
  ```
  
# 스트림 슬라이싱
* 스트림의 요소를 선택하거나 스킵하는 다양한 방법

## Predicate를 이용한 슬라이싱
* `filter` 연산은 기본적으로 **중단 없이** 전체 스트림을 대상으로 이루어진다.
* 데이터가 수없이 많을 수록 `filter` 연산은 점점 느려질 것이다.
* 만약, **자료들이 순차적으로 정리가 잘 되어 있어 True를 반환할때까지만 반복한다면 훨씬 최적화가 잘 될 것이다.**
* JAVA9는 `takeWhile`, `dropWhile` 두 가지 새로운 메소드를 지원해 최적화의 방향을 제시하고 있다.

### 샐러드 가게
* 한 샐러드 가게에 다음과 같은 메뉴들이 있다.
* 이 가게는 다이어트를 하는 손님들을 위해서 칼로리를 낮은 순서부터 나열을 해 놓았다.

|메뉴|닭가슴살 샐러드|계란 샐러드|연어 샐러드|치킨 샐러드|목살 스테이크|소고기 스테이크|
|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|칼로리|450|480|520|700|1020|1250|

### takeWhile
이 가게가 성공을 해서 셀수 없도록 많은 메뉴들을 개발했다고 하자.  
후에 저칼로리용 메뉴판을 따로 만들고 싶은데 다행이 칼로리가 낮은 순으로 나열을 해 놓았다.  
이런경우 `takeWhile`을 이용하면 간단하게 처리할 수 있다.
```java
static void takeWhile() {
    List<Dish> takeWhileDishes = menu.stream()
            .takeWhile(dish -> dish.getCalories() < 800)
            .collect(toList());
    System.out.println(takeWhileDishes);
}
```
`결과 : 닭가슴살 샐러드, 계란 샐러드, 연어 샐러드, 치킨 샐러드`
* 이 경우 **칼로리가 800보다 작은 경우에 연산을 중단**한다. 
* 즉 **false를 반환할 때 까지 연산을 실시한다 보면 된다.**(일반적인 `while` 문이랑 같다고 보면 됨.)

### dropWhile
이번에는 고칼로리용 메뉴를 만드는 경우를 보자
* 이런 케이스에서 `takeWhile`은 사용하기 어렵다. (시작부터 false를 반환하기 때문에 바로 연산이 중단된다.)
* **true인 요소들을 버린 나머지 요소들을 선택하고 싶은 경우** `dropWhile`을 사용하자.
    ```java
    static void dropWhile() {
        List<Dish> dropWhileDishes = menu.stream()
                .takeWhile(dish -> dish.getCalories() < 320)
                .collect(toList());
        System.out.println(dropWhileDishes);
    }
    ```
    `결과 : 목살 스테이크, 소고기 스테이크`
    * 이 경우 **칼로리가 800보다 큰 순간부터 연산을 실시한다.**
    * **`Predicate` 가 처음으로 거짓이 되는 지점까지의 요소를 버림.**

### 요약
<img src="/image/JAVA8/ch5/ch5_1.png" alt="filter-takeWhile-dropWhile차이.png" class="align-center">
* **빨간 박스가 최종적인 요소**이고 **파란 박스는 연산 시 놓치는 요소**를 의미함.
* 이렇게 `takeWhile`과 `dropWhile`는 내림차순이든 오름차순이든 정렬이 잘된 케이스에서는 강력한 퍼포먼스를 보여준다.
* 하지만 뒤에 **정렬이 안된 데이터들을 캐치하지 못하는 실수가 나올 수 있으니, 예외처리를 꼼꼼히 해야 함.**

## 스트림 축소
### limit
* **주어진 값 이하의 크기를 갖는 새로운 스트림을 반환.**
* `limit(n)` 이라면 최대 n개의 요소까지만 선택할 수 있다.

## 요소 건너뛰기
### skip
* **처음 n개 요소를 제외한 스트림을 반환**
* `skip(n)`
    * 처음 n개 요소를 건너 뛰고 다음 요소부터 반환.
    * **만약 n개 이하의 요소를 포함하는 스트림인 경우 빈 스트림이 반환.**

  
  
## 요약
#### 탐색
* `filter` : boolean 타입을 기준으로 true를 반환하는 요소들만 선택
* `takeWhile` : 최초의 false가 반환될때 까지 요소들을 선택
* `dropWhile` : 최초의 false의 요소를 기준으로 앞의 요소들을 버리고 나머지 선택.
  * `filter vs takeWhile, dropWhile` : filter는 모든 요소를 탐색, 나머지는 조건을 만족하는 순간 연산 종료

#### 슬라이싱
* `distinct` : 중복 제거
* `limit(n)` : n개의 요소를 반환(더 적으면 적은대로 반환)
* `skip(n)` : 처음 n개 요소를 건너 뛰고 그다음 요소부터 반환. (n개보다 적은 요소를 가지는 스트림이라면 빈 스트림 반환)


### 참고 자료
* 모던 자바 인 액션
* JAVA Reference
---
title: "03. 람다 표현식"
categories:
    - JAVA8
tags:
  - JAVA8
  - Lambda
last_modified_at: 2021-05-15
---

JAVA8의 두번째 동작 파라미터화 입니다.

# 람다
* **메소드로 전달할 수 있는 익명 함수를 단순화한 것**
    * 함수 : 메소드와 달리 특정 클래스에 종속되지 않음. (파라미터 리스트, 바디, 반환형식, 예외 리스트는 가질 수 있다.)
    
## 람다의 구성 요소
* 람다는 **파라미터, 화살표, 바디**로 이루어져 있다.  
![람다의 구성 요소.png](../image/java8/ch3/ch3_1.png)
* **람다 바디** : 반환값에 해당하는 표현식.
    

## 람다 작성하기
### Basic
* 람다 표현식은 `함수형 인터페이스`에서만 사용이 가능하다.

  ### 함수형 인터페이스
  * **오직 하나의 추상 메소드만을 지정하는 인터페이스를 함수형 인터페이스**라 한다.
    * 2장에서 만든 `Predicate<T>` 인터페이스가 함수형 인터페이스다
  
  * 번외로 함수형 인터페이스를 가르키는 `@FunctionalInterface` 어노테이션이 있다.
    * 실제로 함수형 인터페이스가 아니라면 컴파일러 에러를 발생시킨다.
    * ex: 추상메소드가 1개 이상 -> `"Multiple non-overriding abstract methods found in Interface"`

  ### 함수 디스크립터
  * 함수형 인터페이스의 추상 메소드 시그니처는 **람다 표현식의 시그니처**를 가르킨다.
  * **람다 표현식의 시그니처를 서술하는 메소드를 함수 디스크럽터 라고 부른다.**
    * 시그니처 : 파라미터 + 리턴
  
## 람다 규칙
### 1st. return을 명시적으로 사용하지 않아도 된다
* **return을 명시적으로 사용해도, 사용하지 않아도 상관 없다.**
    ```java
    // 두 코드 모두 문자열 Hello를 반환.
    () -> "Hello"
    () -> {return "Hello";}
    ```
  
### 2nd. 여러 행의 코드를 가질 수 있다.
* 블록 안에 여러 행의 코드를 가질 수 있다.
    ```java
    (int x, int y) -> {
        System.out.println("합의 결과");
        System.out.println("x + y = " + x + y);
    }
    ```
### 3rd. 람다 표현식을 사용할때는 **구문보다 표현식을 사용해라.**
* 구문(statement)은 아무것도 리턴하지 않기 때문에 사이드 이팩트가 발생할 수 있다.
* 표현식은 두개이상의 표현식을 하나로 조합하여 사용할 수 있다.


## 학생 기록부 V6
* 이전 장의 filter 메소드를 가지고 오자.
    ```java
    public static List<Student> predicateFilterV4(List<Student> students, StudentPredicate p) {     
          List<Student> result = new ArrayList<>();
          for (Student student : students) {
              if (p.test(student)) result.add(student);
          }
          return result;
    }
    ```
* 람다의 구성 요소에 맞게 변환을 하면 다음과 같은 람다식이 나온다.
    ```java
    public List<Student> maleStudents = predicateFilterV6(students, (Student s) -> s.getGender().equals(Gender.Male));
    ```

### 람다 표현식



#### 테스트
* `() -> {}` : void를 반환하는 바디가 없는 람다 표현식이다.
* `() -> "Raoul"` : return을 함축하고 있기 때문에 문자열 "Raoul"이 리턴된다.
* `() -> {return "Mario";}` : return을 써도 상관은 없다. "Mario"가 리턴된다.
* `(Integer i) -> return "Alan" + i;` : 흐름 제어문. 바디에 블록을 만들어야 한다. `{return "Alan" + i;}`
* `(String s) -> {"Iron Man"};` : 구문이 아니라 표현식이다. `{return "Iron Man}";` 또는 `"Iron Man"`으로 써야 한다.





## 람다 활용
### 실행 어라운드 패턴
* 기본적으로 자원처리에 사용되는 실행 어라운드 패턴(순환패턴)은 열고 -> 처리하고 -> 닫는 순서로 이루어진다.

#### 1st. 동작 파라미터화
```java
private String oldProcessFile() throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"));) {
        return br.readLine();}
}
```
#### 2nd. 함수형 인터페이스 생성
```java
@FunctionalInterface
private interface BufferReaderInterface {
    void processFile()
}
```
#### 3nd. 동작 실행
```java
private void processFile(
        
        ){
    
        }
```
#### 4nd. 람다를 통한 인터페이스 구현(파라미터 전달)

### 기본형 특화
* 자바는 기본형(Primitive : boolean, char, byte, short, int, long, float, double)과 참조형(Reference : Primitive 제외 전부)이 있다.
* 이때까지는 제네릭 함수형 인터페이스를 살펴봤다.
* 기본적으로 **제네릭 파라미터는 참조형만 가능**하다. 이는 제네릭 내부 구현때문에 어쩔 수 없다.
    * 이를 해결하기 위해서 **기본형을 참조형으로 변환하는 기능을 제공하는데 이를 `박싱`이라 한다.**
    * **참조형을 기본형으로 변환하는 반대 동작을 `언박싱` 이라고 한다.**
    * **보통 명시적으로 쓰지 않아도 변환이 되는데 이를 `오토 박싱`이라 한다.**

* 기본형 특화는 대부분의 함수형 인터페이스명 앞에 타입을 써놓으면 된다.
    * Predicate<T> -> IntPredicate, LongPredicate, DoublePredicate (T -> boolean)
    * Consumer<T> -> IntConsumer<T>, LongConsumer<T>, DoubleConsumer<T> 등등 (T-> void)


## 람다의 주의사항
### 예외를 던지는 함수형 인터페이스
* 함수형 인터페이스는 확인된 예외를 던지는 동작을 허용하지 않음.
* 그러므로 예외를 던지는 람다 표현식을 만들려면... (`ExceptionLambda.java`)
    * **확인된 예외를 선언하는 함수형 인터페이스를 직접 정의**
    * 람다를 **try/catch 블록**으로 감싸야함.


### 지역 변수 사용
* 람다 표현식에서는 익명함수가 하는 것처럼 자유변수를 활용할 수 있는데 이를 `람다 캡처링`이라고 부른다.
    * 자유 변수 : 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수 (멤버 변수)

* 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처(자신의 바디에서 참조) 할 수 있다.
* 하지만, 지역 변수는 명시적으로 final로 선언되어 있어야 하거나, final로 선언된 변수와 처럼 취급 되어야 한다.
    * 인스턴스 변수 캡쳐는 `final, 지역 변수, this` 를 캡쳐하는 것과 마찬가지.

* 그럼 왜 이렇게 해야 할까? 이는 자바의 특성에 대해 알아봐야 한다.
    * 일단 인스턴스 변수는 힙에 저장되고, 지역 변수는 스택에 위치한다.
    * 만약 람다에서 지역변수에 바로 접근이 가능할 때 스레드에서 실행이 되면, 변수를 할당한 스레드가 사라져 변수 할당이 해제되었는데도
      람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다.
    * 그렇게 되면 자유 지역 변수의 복사본을 제공하게 되는데, 복사본의 값이 바뀌어서는 안되기 때문에 final로 할당을 해야 한다.


## 람다 추가 활용
### 형식추론 (Type)
* 람다가 사용되는 Context(람다가 전달될 메소드 파라미터나 람다가 할당되는 변수)를 이용해 람다의 형식을 추론할 수 있다.
* 람다 표현의 형식을 대상 형식(Target Type)이라고 부름.

* 만약 함수형 인터페이스 제네릭에 형식(Type)이 명시되어 있다면, 형식추론을 이용해 더 간략화 할 수 있다. (TypeInference)
```java
// 형식 추론
Comparator<Apple> c1 = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); 
// 형식 추론 X
Comparator<Apple> c2 = (aa1, aa2) -> aa1.getWeight().compareTo(aa2.getWeight());   
```

## 메소드 참조
* 메소드 참조를 사용하면 기존의 메소드 정의를 재활용해서 람다처럼 전달할 수 있다.

    * 예시

      |람다|메소드참조|
          |:----:|:----:|
      |`(Apple apple) -> apple.getWeight()`|`Apple::getWeight`|
      |`() -> {Thread.currentThread().dumpStack()}`|`Thread.currentThread()::dumpStack`|
      |`(str, i) -> str.substring(i)`|`String::substring`|
      |`(String s) -> System.out.println(s) (String s)`|`System.out::println`|
      |`-> this.isValidNames(s)`|`this::isValidNames`|

### 생성자 참조
* `ClassName:new`와 같이 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다. (`ConstRefer.java` 참고)
  ```java
  Supplier<Apple> c1 = new Apple()
  Supplier<Apple> c1 = () -> new Apple();
  Supplier<Apple> c1 = Apple::new;
  Apple a1 = c1.get();
  ```


### 람다 + 메소드 참조
* 이제 배운 모든 것을 활용해서 다음 코드를 간략화 해보자. (`finalCoding.java` 참고)  
  ` inventory.sort((Apple a1, Apple a2) -> Integer.compare(a1.getWeight(), a2.getWeight()));`
#### 1st 코드 전달
* `sort()`의 시그니처는 다음과 같다. : `void sort(Comparator<? super E> c)`
* 함수형 인터페이스 Comparator<T> 객체를 인수로 받아 비교를 하기 때문에, 이는 동작 파라미터화 되었다고 볼 수 있다.
    * `sort`에 전달되는 전략에 따라 `sort`의 방식이 달라질 것이다.
    * `Comparator<Apple>`를 구현하는 다른 인터페이스를 만들어 사용.
    * 최종 : `inventory.sort(new AppleComparator());`

#### 2nd 익명 메소드 사용
* 따로 구현하지 말고 `sort()` 메소드 안에서 구현하자.
    ```java
    void second() {
        inventory.sort(new Comparator<Apple>() {
            @Override
            public int compare(Apple a1, Apple a2) {
                return ((Integer) a1.getWeight()).compareTo(a2.getWeight());
            }
        });
    }
    ```
#### 3rd 람다식으로 변환
* 구현한 익명 메소드를 람다식으로 변경하자
    ```java
    void third() {
        inventory.sort((Apple a1, Apple a2) -> ((Integer) a1.getWeight()).compareTo(a2.getWeight()));
        // Comparator<Apple>를 더 간소화할 수 없을까? -> comparing() 사용
        Comparator<Apple> c1 = comparing((Apple a) -> a.getWeight());
    }
    ```

#### 4th 메소드 참조 사용
* 구현한 람다식을 메소드 참조를 사용하자.
    * `Apple` 클래스의 `getWeight()` 메소드를 사용하고 있다.
      ```java
      void forth() {
          // Apple.getweight() 정적메소드 참조
          Comparator<Apple> c1 = comparing((Apple::getWeight));
          inventory.sort(c1);
      }
      ```

### 람다 표현식 조합
* 함수형 인터페이스는 여러개의 람다 표현식을 조합해서 복잡한 람다 표현식을 만들 수 있다.
    * **append 형식으로 만들기 가능.**
* 함수형 인터페이스의 추상 메소드는 하나인데, 어떻게 이게 가능할까? (함수형 인터페이스의 함수는 하나여야만 한다.)
* 여기서 등장하 는것이 `디폴트 메소드`이다.

#### Comparator 조합
* case1: 역정렬
* reverse()를 통해 역정렬을 할 수 있다.
    * `inventory.sort(comparing(Apple::getWeight).reversed());`

#### Predicate 조합
* case1: negate() 디폴트 메소드를 통한 boolean 타입 역전
    * 빨강사과에서 negate()를 통해 boolean 반전을 시킬 수 있다.
  ```java
  //case1 : negate()를 쓰면 true가 false가 된다.
  Predicate<Apple> redApple = apple -> apple.getColor().equals(Color.RED);
  Predicate<Apple> noRedApple = redApple.negate();
  ```
* case2: and()와 or()을 통한 추가 조건 걸기
    * 기존 조건에서 and(), or()를 통해 추가 조건을 걸 수 있다.
  ```java
  //case2 : 150g 이상인 빨간사과 or 그냥 녹색사과
  Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);
  Predicate<Apple> redAndHeavyAppleOrGreen = redApple.and(apple -> apple.getWeight() > 150)
             .or(apple -> apple.getColor().equals(Color.GREEN));
  ```

#### Function 조합
* case1: andThen() : 주어진 함수를 먼저 적용한 결과를 다른 함수의 입력으로 전달하도록 반환.
  ```java
  //case1 : andThen()를 쓰면 앞에꺼 실행 후 결과를 뒤에꺼에 넣음.
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  
  // f 먼저 실행 후 g 실행
  Function<Integer, Integer> h = f.andThen(g);
  // 4 반환
  int result = h.apply(1);
  ```
* case2: compose() : 인수로 주어진 함수를 먼저 실행한 후 그 결과를 외부 함수의 인수로 제공.
  ```java
  //case2:  인수로 주어진 함수를 먼저 실행 후 결과를 외부 함수의 인수로 제공
  Function<Integer, Integer> f2 = x -> x + 1;
  Function<Integer, Integer> g2 = x -> x * 2;
    
  //g 먼저 실행 후 f 실행
  Function<Integer, Integer> h2 = f.compose(g);
  //3 반환
  int result2 = h2.apply(1);
  ```

## 요약
* 람다 표현식은 익명함수의 일종!
    * **이름은 없으나, 파라미터 리스트 바디 반환 형식을 가지며 예외를 던질 수 있다.**
* 함수형 인터페이스는 하나의 추상 메소드만을 정의하는 인터페이스
    * 함수형 인터페이스에만 람다 표현식으로 대체할 수 있다.
    * **람다 표현식 전체가 함수형 인터페이스의 인스턴스토 취급된다.**
* 실행 어라운드 패턴을 람다와 활용하면 유연성과 재사용성을 추가로 얻을 수 있다.
* 람다 표현식의 기대 형식을 대상 형식이라고 한다.
* 메소드 참조를 이용하면 기존의 메소드 구현을 재사용하고 직접 전달할 수 있다.

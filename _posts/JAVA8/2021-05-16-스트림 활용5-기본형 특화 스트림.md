---
title: "스트림 활용 : 기본형 특화 스트림"
excerpt: "기본형 특화 스트림을 통해 다양한 연산에 대한 대응방식을 확보하자"
categories:
  - JAVA8
  tags:
  - Stream
last_modified_at: 2021-05-16
---

## 숫자형 스트림
* 이전에 배운 `reduce`에서 연산들은 사실 `오토박싱` 비용이 숨어 있다. **기본적으로 중간연산은 모두 `Stream`을 반환하기 때문**이다.
  * 타입이`Integer`이 아닌 `Stream<Integer>`이다.
* 그렇기 때문에 기본적으로 `Integer` 메소드를 사용하지 못한다.
  * ex: `dish.stream().map(Dish::getPrice).sum()` **-> `sum()` 사용 불가.**
* **이런 경우 기본형 특화 스트림**으로 변환(언박싱)을 하면 사용이 가능하다.
    * ex: `dish.stream().mapToInt(Dish::getPrice).sum()` **-> `sum()` 사용 가능.**

### 종류
* `mapToInt` : 기본적으로 map과 같은 기능 수행, **Stream<T> 대신 IntStream 반환**
* `mapToDouble`: 기본적으로 map과 같은 기능 수행, **Stream<T> 대신 DoubleStream 반환**
* `mapToLong`: 기본적으로 map과 같은 기능 수행, **Stream<T> 대신 LongStream 반환**
    

### 일반 스트림으로 복원
* 연산 후 다시 일반 스트림(Stream<Integer> 등)으로 복원(박싱)을 해야 한다.
* `boxed()` 메소드를 사용하자.
```java
Stream<Integer> stream1 = intStream.boxed()
Stream<Double> stream2 = doubleStream.boxed()
Stream<Long> stream3 = longStream.boxed()
```


### 기본값 : OptionalInt
* 만약 스트림 연산결과가 null이면 어떻게 해야 할까? 
* 이런 경우를 대비하기위해서 만들어진 `Optional<T>`을 얘기한적이 있다. 하지만 이는 또 **박싱과 언박싱 자원을 소모**해야 한다.
* 이를 숫자형 스트림에도 적용이 가능하다.
    * `OptionalInt`
    * `OptionalDouble`
    * `OptionalLong`
* 덕분에 불필요한 박싱과 언박싱이 없어진다.
* 이제 이 타입들의 `orElse(기본값)`을 이용해서 값이 없을때 사용할 기본값을 명시적으로 정의할 수 있다.

### 숫자범위
* 특정 범위의 숫자를 이용해야 하는 상황이 자주 발생한다. (ex: 1에서 100 사이의 숫자를 생성)
* 이런 경우 숫자형 스트림의 `range(start, end)`, `rangeClosed(start, end)`를 사용한다.
    * `range(start, end)` : 결과에 시작값과 종료값이 포함되지 않음.
    * `rangeCloesd(start, end)` : 결과에 시작값과 종료값이 포함됨.


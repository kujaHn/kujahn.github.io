---
title: "스트림 활용 : 리듀싱"
excerpt: "리듀싱을 통해 복잡한 스트림 연산을 실시하자."
categories:
    - JAVA8
  tags:
    - Stream
last_modified_at: 2021-05-16
---
# 리듀싱
* filter 만으로는 복잡한 질의를 표현하기 어렵다.
* 원하는 타입이나 결과가 나올때까지 스트림의 모든 요소를 반복적으로 처리해야 한다. (리듀싱)
* 함수형 프로그래밍 언어에서는 `폴드`라고 부른다.

## reduce
* 우선 `For-Each`를 사용해서 합을 구하는 로직을 만들어보자.
  ```java
  static void forEachSum() {
      int sum = 0;
      for (int x : numbers) {
          sum += x;
      }
  }
  ```
    * 여기서 중요한 포인트들은 다음과 같다.
        * **초기값 `int sum = 0`**
        * **List인 numbers의 변수를 다루는 `int x`**
        * **sum과 x를 더하는 + 연산.**

* `reduce`는 이 값들만 지정을 해주면 반복되는 연산을 추상화 할 수 있다.
  ```java
  static void reduceSum(){
      int sum = numbers.stream().reduce(0, (a, b) -> a + b)
  }
  ```
    * 두 코드를 비교해보면, `reduce(초기값, (연산에 필요한 변수) -> 연산 식` 임을 알 수 있다.
    * 단, **초기값을 받지 않도록 된 `Optional` 같은 경우에는 초기값을 생략한다.**
    
### reduce 연산 과정
* `reduce`는 **스트림이 한개로 줄어들 때 까지 각 요소를 반복해서 조합**한다.  
  <img src="/image/JAVA8/ch5/ch5_5.png" alt="reduce 연산.png" class="align-center">
  
## 스트림 내부 상태
* 스트림 연산이 굉장히 광범위하게 적용할 수 있지만, 주의해야할 점도 있다.
<br></br>
* `map`, `filter` 등은 입력 스트림에서 각 요소를 받아 결과를 출력 스트림으로 보낸다
    * 이들은 보통 **상태가 없고, 이를 내부 상태를 갖지 않는 연산(stateless operation)이라고 부른다.**
<br></br>
* `reduce`, `sum`, `max` 같은 연산은 **결과를 누적할 내부 상태가 필요**하다.
<br></br>
* `sorted`와 `distinct`역시 연산과 `filter`과 `map`과 다르게 내부 요소를 가지고 있다.
    * 내부 정렬이나, 중복을 제거하기 위해서는 과거 이력을 알아야 하기 때문에 당연한 일이다.


# 요약
* `reduce(초기값, (연산에 필요한 변수) -> 연산 식`
* 단, **초기값을 받지 않도록 된 `Optional` 같은 경우에는 초기값을 생략.**
* `reduce`는 **스트림이 한개로 줄어들 때 까지 각 요소를 반복해서 조합**.

## 참고 자료
* 모던 자바 인 액션
* JAVA Reference